package com.jcc.sort;

import java.util.Arrays;

/**
 * 希尔排序
 *  希尔排序，也称 递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是 非稳定排序算法。
 *  希尔排序是基于插入排序的以下两点性质而提出改进方法的：
 *     插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
 *     但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一
 *  希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

 * 基本思想
 *  将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。
 *  可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为1。
 *  更好的步长序列取值可以参考维基百科。

 * 算法描述
 *  选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
 *  按增量序列个数 k，对序列进行 k 趟排序；
 *  每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
 */
public class ShellSort {
    public static void sort(int[] a) {
        int length = a.length;
        int h = 1;
        while (h < length / 3) h = 3 * h + 1;
        System.out.println("h=" + h);
        for (; h >= 1; h /= 3) {
            System.out.println("第二个 h=" + h);
            for (int i = 0; i < a.length - h; i += h) {
                for (int j = i + h; j > 0; j -= h) {
                    if (a[j] < a[j - h]) {
                        int temp = a[j];
                        a[j] = a[j - h];
                        a[j - h] = temp;
                    }
                }
            }
        }
        System.out.println(Arrays.toString(a));
    }
}
